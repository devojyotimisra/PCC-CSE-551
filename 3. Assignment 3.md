# PL/SQL Assignments

## 1. Account Debit with Minimum Balance Check
**Question:** Write a PL/SQL code block to perform a debit transaction of 2,000 from a given account. The block should check if the account balance after the debit remains above a minimum balance of 3,000. If the condition is met, update the account balance in the `ACCT_MSTR20231056` table.

```sql
DROP TABLE ACCT_MSTR20231056 CASCADE CONSTRAINTS;

CREATE TABLE ACCT_MSTR20231056 (
    ACCOUNT_NO VARCHAR(7),
    ACCOUNT_BAL NUMBER(11,2)
);

DESC ACCT_MSTR20231056;

INSERT INTO ACCT_MSTR20231056 VALUES ('AC00001', 3000);
INSERT INTO ACCT_MSTR20231056 VALUES ('AC00002', 7000);
INSERT INTO ACCT_MSTR20231056 VALUES ('AC00003', 10000);

SELECT * FROM ACCT_MSTR20231056;

EDIT PLSQL20231056;

DECLARE
	ACCT_BALANCE NUMBER(11,2);
	ACCT_NO VARCHAR2(7);
	DEBIT_AMT NUMBER(11,2):=2000.00;
	MIN_BAL NUMBER(11,2):=3000.00;
BEGIN
	ACCT_NO:='&ACCT_NO';

	SELECT ACCOUNT_BAL INTO ACCT_BALANCE
	FROM ACCT_MSTR20231056
	WHERE ACCOUNT_NO = ACCT_NO;

	IF (ACCT_BALANCE - DEBIT_AMT) >= MIN_BAL THEN
		UPDATE ACCT_MSTR20231056 SET ACCOUNT_BAL = ACCOUNT_BAL - DEBIT_AMT
		WHERE ACCOUNT_NO = ACCT_NO;
	END IF;
END;
/

@PLSQL20231056;

SELECT * FROM ACCT_MSTR20231056;
```

## 2. Circle Area Calculation using WHILE Loop (Fixed Range)
**Question:** Write a PL/SQL code block to calculate the area of circles for radii varying from 3 to 7 using a `WHILE` loop. Store each radius and its corresponding calculated area in the table `AREAS20231056`.

```sql
DROP TABLE AREAS20231056 CASCADE CONSTRAINTS;

CREATE TABLE AREAS20231056 
(
    RADIUS NUMBER(2),
    AREA NUMBER(11,2)
);

DESC AREAS20231056;

SELECT * FROM AREAS20231056;

EDIT PLSQL20231056;

DECLARE
	PI NUMBER(4,2):=3.14;
	RADIUS NUMBER(5);
	AREA NUMBER(11,2);
BEGIN
	RADIUS:=3;
	WHILE RADIUS<=7
	LOOP
		AREA:=PI*POWER(RADIUS,2);
		INSERT INTO AREAS20231056 VALUES (RADIUS, AREA);
		RADIUS:=RADIUS+1;
	END LOOP;
END;
/

@PLSQL20231056;

SELECT * FROM AREAS20231056;
```

## 3. Transaction Control with SAVEPOINT and ROLLBACK
**Question:** Demonstrate transaction control in PL/SQL. Write a block that performs a bill payment (debit) and a deposit. Use a `SAVEPOINT` before the deposit so that if the total balance across accounts exceeds 200,000 after the deposit, the transaction can be rolled back to the state before the deposit occurred.

```sql
DROP TABLE TRANS_MSTR20231056 CASCADE CONSTRAINTS;

CREATE TABLE TRANS_MSTR20231056
(
	TRANS_NO VARCHAR(4), 
	ACCT_NO VARCHAR(4), 
	DT DATE, 
	TYPE VARCHAR(1), 
	PARTICULAR VARCHAR(50), 
	DR_CR VARCHAR(1), 
	AMT NUMBER(14,2), 
	BALANCE NUMBER(14,2)
);

DESC TRANS_MSTR20231056;

DROP TABLE ACCT_MSTR20231056 CASCADE CONSTRAINTS;

CREATE TABLE ACCT_MSTR20231056 
(
    ACCT_NO VARCHAR(4),
    CURBAL NUMBER(14,2)
);

DESC ACCT_MSTR20231056;

INSERT INTO ACCT_MSTR20231056 VALUES ('CA10', 71000);

SELECT * FROM ACCT_MSTR20231056;

EDIT PLSQL20231056;

DECLARE
	MBAL NUMBER(8,2);
BEGIN
	INSERT INTO TRANS_MSTR20231056 VALUES ('T100', 'CA10', '04-JUL-2004', 'C', 'Telephone Bill', 'W', 1000, 31000);
	
	UPDATE ACCT_MSTR20231056 
	SET CURBAL = CURBAL - 1000 
	WHERE ACCT_NO = 'CA10';

	SAVEPOINT NO_UPDATE;
	
	INSERT INTO TRANS_MSTR20231056 VALUES ('T101', 'CA10', '04-JUL-2004', 'C', 'Deposit', 'D', 140000, 171000);

	UPDATE ACCT_MSTR20231056 
	SET CURBAL = CURBAL + 140000 
	WHERE ACCT_NO = 'CA10';

	SELECT SUM(CURBAL) 
	INTO MBAL 
	FROM ACCT_MSTR20231056;

	IF MBAL > 200000 THEN
		ROLLBACK TO SAVEPOINT NO_UPDATE;
	END IF;

    COMMIT;
END;
/

@PLSQL20231056;

SELECT * FROM TRANS_MSTR20231056;

SELECT * FROM ACCT_MSTR20231056;
```

## 4. Implicit Cursor Attributes (SQL%FOUND and SQL%NOTFOUND)
**Question:** Write a PL/SQL code block to update an employee's branch location in the `EMP_MSTR20231056` table. Use the implicit cursor attributes `SQL%FOUND` and `SQL%NOTFOUND` to print a success message if the update occurs or an error message if the employee ID does not exist.

```sql
DROP TABLE EMP_MSTR20231056 CASCADE CONSTRAINTS;

CREATE TABLE EMP_MSTR20231056 
(
    EMP_NO VARCHAR2(10),
    EMP_NAME VARCHAR2(30),
    BRANCH_NO VARCHAR2(10)
);

DESC EMP_MSTR20231056;

INSERT INTO EMP_MSTR20231056 VALUES ('E1', 'Harry', 'B1');
INSERT INTO EMP_MSTR20231056 VALUES ('E2', 'Blake', 'B2');
INSERT INTO EMP_MSTR20231056 VALUES ('E3', 'Jack', 'B3');

SELECT * FROM EMP_MSTR20231056;

EDIT PLSQL20231056;

BEGIN
    UPDATE EMP_MSTR20231056 SET BRANCH_NO = '&BRANCH_NO' WHERE EMP_NO = '&EMP_NO';
    IF SQL%FOUND THEN
        DBMS_OUTPUT.PUT_LINE('EMPLOYEE SUCCESSFULLY TRANSFERRED');
    END IF;
    IF SQL%NOTFOUND THEN
        DBMS_OUTPUT.PUT_LINE('EMPLOYEE NUMBER DOES NOT EXIST');
    END IF;
END;
/

@PLSQL20231056;

SELECT * FROM EMP_MSTR20231056;
```

## 5. Circle Area Calculation (Range)
**Question:** Write a PL/SQL code block to calculate the area for a value of radius varying from x to y (x & y will be given by the user). Store the radius and the corresponding values of calculated areas in table `AREAS20231056(radius, area)`.

```sql
DROP TABLE AREAS20231056 CASCADE CONSTRAINTS;

CREATE TABLE AREAS20231056
(
	RADIUS NUMBER(5),
	AREA NUMBER(14,2)
);

DESC AREAS20231056;

SELECT * FROM AREAS20231056;

EDIT PLSQL20231056;

DECLARE
	X NUMBER := &X;   
	Y NUMBER := &Y;   
	AREA NUMBER(14,2);
BEGIN
	FOR R IN X .. Y LOOP
		AREA := 3.14 * R * R; 
		INSERT INTO AREAS20231056 VALUES (R, AREA);
	END LOOP;
	COMMIT;
END;
/

@PLSQL20231056;

SELECT * FROM AREAS20231056;
```

## 6. Cursor for Record Counting
**Question:** Print the number of records in the `AREAS20231056` table with the help of a cursor.

```sql
SELECT * FROM AREAS20231056;

EDIT PLSQL20231056;

DECLARE
	CURSOR C_AREAS20231056 IS
		SELECT RADIUS, AREA 
		FROM AREAS20231056;

	V_ROW C_AREAS20231056%ROWTYPE;
	V_COUNT NUMBER := 0;
BEGIN
	OPEN C_AREAS20231056;
	LOOP
		FETCH C_AREAS20231056 INTO V_ROW;
		DBMS_OUTPUT.PUT_LINE('RADIUS: ' || V_ROW.RADIUS || ', AREA: ' || V_ROW.AREA);
		EXIT WHEN C_AREAS20231056%NOTFOUND;
		V_COUNT := V_COUNT + 1;
	END LOOP;
	CLOSE C_AREAS20231056;
END;
/

@PLSQL20231056;
```

## 7. Invert a Number
**Question:** Write a PL/SQL code block for inverting a number.

```sql
EDIT PLSQL20231056;

DECLARE 
    NUM NUMBER(5);
    REV NUMBER(5):=0;
BEGIN
    NUM:='&NUM';
    WHILE (NUM!=0)
    LOOP
        REV:=(REV*10)+MOD(NUM,10);
        NUM:=FLOOR(NUM/10);
    END LOOP;
    DBMS_OUTPUT.PUT_LINE('REV NUM:' || REV);
END;
/

@PLSQL20231056;
```

## 8. Sum of Digits
**Question:** Write a PL/SQL code block to calculate the sum of all digits of a number.

```sql
EDIT PLSQL20231056;

DECLARE
    NUM NUMBER(10);
    S NUMBER(10):=0;
BEGIN
    NUM:='&NUM';
    WHILE(NUM!=0)
    LOOP
        S:=S+MOD(NUM,10);
        NUM:=FLOOR(NUM/10);
    END LOOP;
    DBMS_OUTPUT.PUT_LINE('SUM = ' || S);
END;
/

@PLSQL20231056;
```

## 9. Maximum of Three Numbers (Function)
**Question:** Write a PL/SQL function to return the maximum of three numbers.

```sql
EDIT PLSQL20231056;

CREATE OR REPLACE FUNCTION MAX3 (A NUMBER, B NUMBER, C NUMBER) RETURN NUMBER IS
BEGIN
    IF A=B AND A=C AND B=C
    THEN
        RETURN A;
    END IF;

    IF (A=B AND A>C) OR (A=C AND A>B)
    THEN
        RETURN A;
    END IF;

    IF (B=A AND B>C) OR (B=C AND B>A)
    THEN
        RETURN B;
    END IF;

    IF (C=A AND C>B) OR (C=B AND C>A)
    THEN
        RETURN C;
    END IF;

    IF A>B AND A>C
    THEN   
        RETURN A;
    END IF;

    IF B>A AND B>C
    THEN 
        RETURN B;
    END IF;

    IF C>A AND C>B
    THEN 
        RETURN C;
    END IF;
END;
/

DECLARE
    A NUMBER(5);
    B NUMBER(5);
    C NUMBER(5);
    R NUMBER(5);
BEGIN
    A:='&A';
    B:='&B';
    C:='&C';

    R:=MAX3(A,B,C);

    DBMS_OUTPUT.PUT_LINE('MAX = ' || R);
END;
/

@PLSQL20231056;
```

## 10. Factorial Calculation (Function)
**Question:** Write a PL/SQL function to calculate the factorial of a given number `n` as an argument. Use the function to store `n` and `fact(n)` in a table `Fact_table`.

```sql
DROP TABLE FACT_TABLE20231056 CASCADE CONSTRAINTS;

CREATE TABLE FACT_TABLE20231056 
(
	N NUMBER,
	FACT_VALUE NUMBER
);

DESC FACT_TABLE20231056;

SELECT * FROM FACT_TABLE20231056;

EDIT PLSQL20231056;

CREATE OR REPLACE FUNCTION FACTORIAL(N IN NUMBER)
RETURN NUMBER 
IS
    F NUMBER := 1;
BEGIN
    IF N < 0 THEN
        RETURN NULL;   
    END IF;

    FOR I IN 1 .. N LOOP
        F := F * I;
    END LOOP;

    RETURN F;
END;
/

DECLARE
    NUM NUMBER := &N;   
    FACT NUMBER;
BEGIN
    FACT := FACTORIAL(NUM);

    INSERT INTO FACT_TABLE20231056 VALUES (NUM, FACT);
    COMMIT;

    DBMS_OUTPUT.PUT_LINE('NUMBER = ' || NUM);
    DBMS_OUTPUT.PUT_LINE('FACTORIAL = ' || FACT);
END;
/

@PLSQL20231056;

SELECT * FROM FACT_TABLE20231056;
```

## 11. Prime Number Series
**Question:** Write a PL/SQL code block to find the prime numbers from a series of numbers.

```sql
EDIT PLSQL20231056;

CREATE OR REPLACE FUNCTION IS_PRIME(N NUMBER) RETURN NUMBER IS
    S NUMBER:=2;
    C NUMBER:=0;
BEGIN
    IF(N<=0)
    THEN
        RETURN 0;
    END IF;

    WHILE(S<SQRT(N))
    LOOP
        IF MOD(N,S)=0
        THEN
            RETURN 0;
        END IF;

        S:=S+1;
    END LOOP;

    RETURN 1;
END;
/

DECLARE
    S NUMBER;
    E NUMBER;
    TEMP NUMBER;
BEGIN
    S:='&S';
    E:='&E';
    WHILE(S<=E)
    LOOP
        TEMP:=IS_PRIME(S);
        IF TEMP=1
        THEN
            DBMS_OUTPUT.PUT_LINE(S);
        END IF;

        S:=S+1;    
    END LOOP;
END;
/

@PLSQL20231056;
```

## 12. Fibonacci Series
**Question:** Write a PL/SQL program to print the first `n` Fibonacci numbers.

```sql
EDIT PLSQL20231056;

DECLARE
    A NUMBER(3):=0;
    B NUMBER(3):=1;
    N NUMBER(3);
    C NUMBER(3):=2;
    TEMP NUMBER(3);
BEGIN 
    N:='&N';

    DBMS_OUTPUT.PUT_LINE(A);
    DBMS_OUTPUT.PUT_LINE(B);

    WHILE(C<=N)
    LOOP
        TEMP:=A+B;

        DBMS_OUTPUT.PUT_LINE(TEMP);

        A:=B;
        B:=TEMP;

        C:=C+1;
    END LOOP;
END;
/
 
@PLSQL20231056;
```

## 13. Digit Analysis (Count, Sum, Prime Check)
**Question:** Write a PL/SQL program that will accept a number and then count the number of digits, sum of digits, and check whether the sum is prime or not.

```sql
EDIT PLSQL20231056;

DECLARE
    NUM NUMBER := &NUM;   
    TEMP NUMBER;
    DIGIT NUMBER;
    DIGIT_COUNT NUMBER := 0;
    DIGIT_SUM NUMBER := 0;
    IS_PRIME BOOLEAN := TRUE;
BEGIN
    TEMP := NUM;
    WHILE TEMP > 0 LOOP
        DIGIT := MOD(TEMP, 10);
        DIGIT_SUM := DIGIT_SUM + DIGIT;
        DIGIT_COUNT := DIGIT_COUNT + 1;
        TEMP := FLOOR(TEMP / 10);
    END LOOP;
    IF DIGIT_SUM < 2 THEN
        IS_PRIME := FALSE;
    ELSE
        FOR I IN 2 .. FLOOR(DIGIT_SUM / 2) LOOP
            IF DIGIT_SUM MOD I = 0 THEN
                IS_PRIME := FALSE;
                EXIT;
            END IF;
        END LOOP;
    END IF;
    DBMS_OUTPUT.PUT_LINE('NUMBER: ' || NUM);
    DBMS_OUTPUT.PUT_LINE('NUMBER OF DIGITS: ' || DIGIT_COUNT);
    DBMS_OUTPUT.PUT_LINE('SUM OF DIGITS: ' || DIGIT_SUM);

    IF IS_PRIME THEN
        DBMS_OUTPUT.PUT_LINE('THE SUM IS A PRIME NUMBER.');
    ELSE
        DBMS_OUTPUT.PUT_LINE('THE SUM IS NOT A PRIME NUMBER.');
    END IF;
END;
/

@PLSQL20231056;
```

## 14. Armstrong Number Check
**Question:** Write a PL/SQL code that will accept a number and check if the number is Armstrong or not.

```sql
EDIT PLSQL20231056;

DECLARE
    NUM NUMBER := &NUM;   
    TEMP NUMBER;
    DIGIT NUMBER;
    DIGITS NUMBER := 0;
    SUM_VAL NUMBER := 0;
BEGIN
    TEMP := NUM;
    
    WHILE TEMP > 0 LOOP
        DIGITS := DIGITS + 1;
        TEMP := FLOOR(TEMP / 10);
    END LOOP;

    TEMP := NUM;

    WHILE TEMP > 0 LOOP
        DIGIT := MOD(TEMP, 10);
        SUM_VAL := SUM_VAL + POWER(DIGIT, DIGITS);
        TEMP := FLOOR(TEMP / 10);
    END LOOP;

    IF SUM_VAL = NUM THEN
        DBMS_OUTPUT.PUT_LINE(NUM || ' IS AN ARMSTRONG NUMBER.');
    ELSE
        DBMS_OUTPUT.PUT_LINE(NUM || ' IS NOT AN ARMSTRONG NUMBER.');
    END IF;
END;
/

@PLSQL20231056;
```

## 15. Proper Case Name Formatting
**Question:** Write a PL/SQL program that will accept a name and then display it in proper case (e.g., "jim morrison" output "J. Morrison").

```sql
EDIT PLSQL20231056;

DECLARE
    FULL_NAME VARCHAR2(50) := '&FULL_NAME';  
    FIRST_NAME VARCHAR2(30);
    LAST_NAME  VARCHAR2(30);
    SPACE_POS  NUMBER;
BEGIN
    SPACE_POS := INSTR(FULL_NAME, ' ');

    FIRST_NAME := SUBSTR(FULL_NAME, 1, SPACE_POS - 1);
    LAST_NAME := SUBSTR(FULL_NAME, SPACE_POS + 1);

    DBMS_OUTPUT.PUT_LINE(
        UPPER(SUBSTR(FIRST_NAME, 1, 1)) || '. ' ||
        INITCAP(LAST_NAME)
    );
END;
/

@PLSQL20231056;
```